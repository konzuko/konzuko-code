// src/hooks/useTokenizableContent.js
// NOTE: The token count derived from the items generated by this hook
// is displayed in the UI under the label "MEMORY".

import { useMemo } from 'preact/hooks';

// This helper processes the message history. It's memoized so it doesn't
// re-run unless the messages array actually changes.
const useMemoizedMessageItems = (messages) => {
    return useMemo(() => {
        if (!messages || messages.length === 0) return [];
        
        const messageItems = [];
        messages.forEach(msg => {
            const contentBlocks = Array.isArray(msg.content)
                ? msg.content
                : [{ type: 'text', text: String(msg.content ?? '') }];

            contentBlocks.forEach(block => {
                if (block.type === 'text' && block.text && String(block.text).trim() !== "") {
                    messageItems.push({ type: 'text', value: block.text });
                } else if (block.type === 'file' && block.file?.file_id && block.file?.mime_type && block.file.mime_type.includes('pdf')) {
                    messageItems.push({ type: 'pdf', uri: block.file.file_id, mimeType: block.file.mime_type });
                }
            });
        });
        return messageItems;
    }, [messages]);
};

export function useTokenizableContent(
    currentChatMessages,
    userPromptText, // This is the pre-constructed text from usePromptBuilder
    currentPendingPDFs,
    isSending // Parameter to indicate if a message is currently being sent
) {
    // Memoize the expensive part (iterating all messages)
    const memoizedMessageItems = useMemoizedMessageItems(currentChatMessages);

    // This final memo combines the already-processed parts. It's very fast to run,
    // even on every keystroke, because its dependencies are stable.
    return useMemo(() => {
        const itemsForApiCount = [...memoizedMessageItems];

        // If NOT currently sending, add the content for the next message.
        if (!isSending) {
            if (userPromptText && String(userPromptText).trim() !== "") {
                itemsForApiCount.push({ type: 'text', value: userPromptText });
            }
            if (currentPendingPDFs && currentPendingPDFs.length > 0) {
                currentPendingPDFs.forEach(pdf => {
                    itemsForApiCount.push({ type: 'pdf', uri: pdf.fileId, mimeType: pdf.mimeType });
                });
            }
        }
        // Note: Pending images are not added here; their token cost is estimated separately in App.jsx.

        return itemsForApiCount;

    }, [memoizedMessageItems, userPromptText, currentPendingPDFs, isSending]);
}
